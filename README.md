# Фаткин К. УИБО-14-24
## 1. Алгоритм минимального элемента (Minimum Element Selection)
**Принцип работы**: На каждом этапе обработки находится наименьший элемент в необработанной части массива и производится его обмен с текущим элементом последовательности.

**Детальный анализ**:
Процесс начинается с полного просмотра массива для определения минимального значения, которое затем перемещается на первую позицию. На последующих итерациях область поиска последовательно сокращается, исключая уже отсортированные элементы. Для каждого нового сегмента повторяется операция поиска минимума и его размещения в начале необработанного участка.

**Вычислительная сложность**: O(n²) - обусловлена использованием двойного цикла, где каждый элемент последовательно сравнивается со всеми последующими.

## 2. Алгоритм последовательного обмена (Bubble Exchange Method)
**Принцип работы**: Многократный проход по массиву с попарным сравнением соседних элементов и их обменом при нарушении порядка следования.

**Детальный анализ**:
- Определяется общее количество элементов массива
- Внешний цикл контролирует количество необходимых проходов
- Внутренний цикл обрабатывает пары элементов, перемещая более крупные значения к концу массива
- Процесс завершается при отсутствии обменов за полный проход

**Вычислительная сложность**: O(n²) в худшем и среднем случаях из-за вложенных циклов, зависимых от размера входных данных.

## 3. Алгоритм последовательного включения (Insertion Method)
**Принцип работы**: Поэтапное построение упорядоченной последовательности путем вставки каждого следующего элемента в правильную позицию относительно уже отсортированных.

**Детальный анализ**:
Изначально считается, что первый элемент образует отсортированный сегмент. Для каждого последующего элемента выполняется поиск корректной позиции в упорядоченной части с одновременным сдвигом элементов для освобождения места.

**Вычислительная сложность**: O(n²) - количество операций растет квадратично с увеличением объема данных.

## 4. Алгоритм с переменным шагом (Shell's Interval Method)
**Принцип работы**: Усовершенствование метода вставок с использованием переменного интервала между сравниваемыми элементами.

**Детальный анализ**:
- Функция `insertion_sort_gap` выполняет сортировку элементов, расположенных на расстоянии заданного шага
- Функция `shell_sort` управляет последовательным уменьшением интервала
- На каждом шаге обрабатываются независимые подпоследовательности

**Вычислительная сложность**: O(n^1.5) - улучшенная производительность по сравнению с классическими квадратичными алгоритмами.

## 5. Алгоритм быстрого упорядочивания (Rapid Partitioning Sort)
**Принцип работы**: Основан на стратегии "разделяй и властвуй" с выбором опорного элемента и рекурсивной сортировкой образованных сегментов.

**Детальный анализ**:
- Функция `quickSort` принимает границы обрабатываемого участка
- Функция `partition` выбирает опорный элемент и перераспределяет элементы относительно него
- Рекурсивные вызовы обрабатывают левую и правую части относительно опорного элемента

**Вычислительная сложность**: O(n log n) - логарифмическая зависимость благодаря рекурсивному разделению.

## 6. Алгоритм древовидной организации (Heap Structure Method)
**Принцип работы**: Построение специальной древовидной структуры (кучи) с последующим извлечением элементов в порядке убывания приоритета.

**Детальный анализ**:
- Функция `heapify` поддерживает свойства древовидной структуры
- Начальный этап - построение максимальной кучи из исходного массива
- Последовательное извлечение корневого элемента и восстановление свойств кучи

**Вычислительная сложность**: O(n log n) - эффективное управление структурой данных.

## 7. Метод последовательного просмотра (Linear Scanning)
**Принцип работы**: Поочередная проверка каждого элемента коллекции до обнаружения искомого значения или завершения просмотра.

**Детальный анализ**:
Функция последовательно сравнивает каждый элемент с целевым значением. При совпадении возвращается позиция элемента, при отсутствии - специальный индикатор.

**Вычислительная сложность**: O(n) - линейная зависимость времени выполнения от размера данных.

## 8. Метод половинного деления (Binary Division Search)
**Принцип работы**: Эффективный поиск в упорядоченных коллекциях путем последовательного деления области поиска пополам.

**Детальный анализ**:
1. Установка начальных границ поиска
2. Циклическое вычисление средней точки
3. Сравнение среднего элемента с искомым значением
4. Корректировка границ на основе результата сравнения

**Вычислительная сложность**: O(log n) - логарифмическая зависимость благодаря экспоненциальному сокращению области поиска.

## 9. Метод интерполяционного прогнозирования (Interpolation Prediction Search)
**Принцип работы**: Усовершенствованный поиск в равномерно распределенных отсортированных данных с прогнозированием позиции искомого элемента.

**Детальный анализ**:
1. Инициализация границ поиска
2. Вычисление предполагаемой позиции на основе значений границ
3. Постепенное сужение области поиска

**Вычислительная сложность**: O(log log n) - сверхлогарифмическая эффективность при равномерном распределении.

## 10. Метод золотого сечения (Fibonacci Sequence Search)
**Принцип работы**: Поиск в отсортированных данных с использованием последовательности Фибоначчи для определения позиций сравнения.

**Детальный анализ**:
1. Определение чисел Фибоначчи, соответствующих размеру массива
2. Поэтапное сужение области поиска с использованием математических соотношений
3. Сравнение элементов в вычисленных позициях

**Вычислительная сложность**: O(log n) - сопоставима с бинарным поиском.

## 11. Алгоритм пошагового включения (Step-by-Step Insertion)
**Принцип работы**: Постепенное формирование упорядоченной последовательности путем вставки элементов в соответствующие позиции.

**Детальный анализ**:
- Построение отсортированного сегмента начинается с первого элемента
- Каждый следующий элемент помещается в корректную позицию относительно уже упорядоченных
- Сдвиг элементов для освобождения места при необходимости

**Вычислительная сложность**: O(n²) - квадратичная зависимость в худшем случае.
